<!DOCTYPE html>
<html>
<head>
	<title>Clone of Ben Olding's Warlords</title>
</head>
<!--<body onmousemove="mouseMove(event)" onmousedown="mouseDown()" onmouseup="mouseUp()" onkeydown="pressedKey(event)">-->
<body onkeypress="pressedKey(event)">

<img id="pikeman" style="display: none;" src="pikeman2.png">
<img id="poleaxer" style="display: none;" src="poleaxer.png">
<img id="bardicher" style="display: none;" src="bardicher.png">
<img id="archer" style="display: none;" src="archer.png">

<img id="arrow" style="display: none;" src="arrow.png">

<div>
	<canvas id="gameScreen" width="1000" height="570" onmousedown="mouseDownCanvas(event)" onmousemove="mouseMoveCanvas(event)" onmouseup="mouseUpCanvas(event)" oncontextmenu="contextMenuCanvas(event)" />
</div>

</body>
<style id="theStyle" type="text/css">
	div {
		text-align: center;
	}
	canvas {
		border: 1px dashed red;
	}
</style>
<script type="text/javascript">

var gameScreen = document.getElementById("gameScreen");
var gctx = gameScreen.getContext("2d");

var mouseDownPos = undefined;
var heldButtons = 0;
var invasionProgress = 50;

//total pixel change in starting x over all 8 lanes
const MAX_X_CHANGE = 150;
const HORIZON_HEIGHT = 150;
const FIELD_WIDTH = 10000;
const FIELD_HEIGHT = 200;
const Z_PER_LANE = [0, 0.11, 0.23, 0.36, 0.50, 0.65, 0.81, 0.98];

const pikeman = {"img":document.getElementById("pikeman"), "fw":100, "fh":100, "attackFrame":4, "frames":7, "totalFrames":10};
const poleaxer = {"img":document.getElementById("poleaxer"), "fw":100, "fh":100, "attackFrame":4, "frames":8, "totalFrames":10};
const bardicher = {"img":document.getElementById("bardicher"), "fw":100, "fh":100, "attackFrame":4, "frames":11, "totalFrames":11};
const archer = {"img":document.getElementById("archer"), "fw":100, "fh":100, "attackFrame":4, "frames":8, "totalFrames":11};

const arrow = {"img":document.getElementById("arrow"), "fw":88, "fh":61};


window.onload = function() {
	//blarg
	window.setInterval(drawGame, 1000/30);
}

function remove(array, item) {
	for (let i = array.length - 1; i >= 0; i--) {
		if (item === array[i]) array.splice(i, 1);
	}
}

function isArray(a) {
	return (Object.prototype.toString.call(a) === "[object Array]");
}
function isObject(a) {
	return (Object.prototype.toString.call(a) === "[object Object]");
}



function pressedKey(event) {
	//console.log(event)
	let player_right = 1 - players[1].isAI, mirror = (player_right === 1 ? -1 : 1);
	if (event.code === "KeyS") {
		players[0].selectedLane++;
		if (players[0].selectedLane > 7) players[0].selectedLane = 0;
	} else if (event.code === "KeyW") {
		players[0].selectedLane--;
		if (players[0].selectedLane < 0) players[0].selectedLane = 7;
	} else if (event.code === "KeyA") {
		players[0].selectedUnit--;
		if (players[0].selectedUnit < 0) players[0].selectedUnit = players[0].allUnits.length - 1;
	} else if (event.code === "KeyD") {
		players[0].selectedUnit++;
		if (players[0].selectedUnit >= players[0].allUnits.length) players[0].selectedUnit = 0;
	} else if (event.key === "ArrowDown") {
		players[player_right].selectedLane++;
		if (players[player_right].selectedLane > 7) players[player_right].selectedLane = 0;
	} else if (event.key === "ArrowUp") {
		players[player_right].selectedLane--;
		if (players[player_right].selectedLane < 0) players[player_right].selectedLane = 7;
	} else if (event.key === "ArrowLeft") {
		players[player_right].selectedUnit -= mirror;
		if (players[player_right].selectedUnit >= players[player_right].allUnits.length) {
			players[player_right].selectedUnit = 0;
		} else if (players[player_right].selectedUnit < 0) {
			players[player_right].selectedUnit = players[player_right].allUnits.length - 1;
		}
	} else if (event.key === "ArrowRight") {
		players[player_right].selectedUnit += mirror;
		if (players[player_right].selectedUnit >= players[player_right].allUnits.length) {
			players[player_right].selectedUnit = 0;
		} else if (players[player_right].selectedUnit < 0) {
			players[player_right].selectedUnit = players[player_right].allUnits.length - 1;
		}
	} /*else {
		console.log(event);
	}*/
}

function getMousePos(event) {
	var bb = event.target.getBoundingClientRect();
	return [event.clientX - bb.left, event.clientY - bb.top];
}

function mouseMove(event) {
	//stuff
	getMousePos(event);
}

function mouseDown() {
	//stuff
	//maybe for drawing lines?
	/*mouseDownPos[0] = mousePos[0];
	mouseDownPos[1] = mousePos[1];*/
}


function getFirstEnemy(side, lane_id, x, range) {
	let lane = players[1 - side].lanes[lane_id];
	let closest_enemy = undefined;
	let closest_distance = Infinity;
	for (let unit_id = 0; unit_id < lane.length; unit_id++) {
		let unit = lane[unit_id];
		let distance = FIELD_WIDTH - unit.x - x
		if (distance > 0 && distance < closest_distance && distance < range) {
			closest_enemy = unit;
			closest_distance = distance;
		}
	}
	return closest_enemy;
}
function getRenderCoords(side, lane_id, x) {
	let z = Z_PER_LANE[lane_id];
	let x_offset = (1.0 - z) * MAX_X_CHANGE;
	let max_x = gameScreen.width - x_offset * 2;
	let apparent_x = x * max_x / FIELD_WIDTH + x_offset;
	if (side === 1) apparent_x = gameScreen.width - apparent_x;
	let apparent_y = FIELD_HEIGHT + z * (gameScreen.height - FIELD_HEIGHT);
	return [apparent_x, apparent_y, z];
}


class Projectile {
	//assumed arrow
	constructor(side, lane_id, x, y, velocity) {
		this.side = side;
		this.lane_id = lane_id;
		this.x = x;
		this.y = y;
		this.velocity = velocity;
	}
	tick() {
		let enemy = getFirstEnemy(this.side, this.lane_id, this.x, this.velocity[0]);
		this.x += this.velocity[0];
		this.y += this.velocity[1];
		this.velocity[0] *= 0.99;
		this.velocity[1] += 0.08;
		if (enemy !== undefined && this.y > -70 && this.y < -10) {
			let speed = DBP(0,0, this.velocity[0], this.velocity[1]);
			enemy.takeDamage("thrust", speed / 19, 0.0);
			remove(players[this.side].projectiles[this.lane_id], this)
		}
		if (this.y > 0) remove(players[this.side].projectiles[this.lane_id], this);
	}
	draw() {
		let coords = getRenderCoords(this.side, this.lane_id, this.x);
		let x = coords[0], y = coords[1], z = coords[2];
		//console.log("arrow", x, y, z, this.y, this.velocity);
		let mirror = this.side === 1 ? -1 : 1;
		drawLine(gctx, x, y + this.y + 15 * z, x + mirror * 20 * (1.0 - 0.4 * (1.0-z)), y + this.y + 15 * z + this.velocity[1] * (1.0 - 0.4 * (1.0-z)), "black");
		//gctx.drawImage(this.anim.img, sx, sy, fw, fh, x, y - fh, fw * (1.0 - 0.4 * (1.0-z)) * mirror, fh * (1.0 - 0.4 * (1.0-z)));
	}
}


class Unit {
	constructor(side, lane_id, x, unit) {
		this.side = side;
		this.lane_id = lane_id;
		this.x = x;
		this.health = 100;
		this.thrustResist = 0.1;
		this.cutResist = 0.0;
		this.bluntResist = 0.2;
		this.attacks = unit.attacks;
		//maybe change it so all attacks are checked through for the highest range?
		this.maxRange = unit.attacks[0].range;
		this.preferredRange = unit.preferredRange || this.maxRange;
		//speed should be roughly 6 times as high as in Warlords: Call to Arms eg. 5 * 6 = 30 for a pikeman
		this.speed = unit.speed * (0.9 + 0.2 * Math.random());
		this.walkFrame = 0;
		this.walkCounter = 0;
		this.currentAttack;
		this.anim = unit.img_info;
	}
	//WHY the fuck is piercing not dependent on the dealer?
	takeDamage(type, amount, piercing) {
		if (type === "thrust") {
			amount *= (1 - this.thrustResist * (1 - piercing) );
		}
		this.health -= amount;
		if (this.health < 0) {
			remove(players[this.side].lanes[this.lane_id], this);
			players[1 - this.side].chargeProgress += 1;
		}
	}
	tick() {
		if (this.x > FIELD_WIDTH) {
			remove(players[this.side].lanes[this.lane_id], this);
			invasionProgress += (this.side === 0 ? 1 : -1);
		}
		let enemy = getFirstEnemy(this.side, this.lane_id, this.x, this.maxRange);
		let distance = Infinity;
		if (enemy !== undefined) {
			distance = Math.abs(this.x + enemy.x - FIELD_WIDTH);
			if (!this.currentAttack) {
				let potential_attacks = [];
				let total_weight = 0;
				for (let i = 0; i < this.attacks.length; i++) {
					//console.log("blarg", this.attacks.length, this.maxRange, distance, this.attacks[i].range);
					if (distance <= this.attacks[i].range) {
						//if (this.attacks.length === 1) console.log("blarg")
						potential_attacks.push(this.attacks[i]);
						total_weight += this.attacks[i].weight;
					}
				}
				if (potential_attacks.length === 0) {
					console.log("weirdness", this.attacks.length);
					return;
				}
				let choice = total_weight * Math.random();
				let attack;
				for (let i = 0; i < potential_attacks.length; i++) {
					attack = potential_attacks[i];
					choice -= attack.weight;
					if (choice < 0) {
						break;
					}
				}
				//console.log(enemy)
				//console.log(attack)
				this.currentAttack = attack;
				this.walkFrame = attack.frame;
			}
			if (this.currentAttack.type !== "shoot" && this.walkFrame === this.currentAttack.frame && this.walkCounter === 1) {
				//wth is up with piercing being hardcoded
				enemy.takeDamage(this.currentAttack.type, this.currentAttack.maxDamage * (0.8 + 0.2 * Math.random()), 0.4)
			} else if (this.currentAttack.type === "shoot" && this.walkFrame === this.currentAttack.frame + this.currentAttack.fn - 1 && this.walkCounter === 1) {
				//launch projectile
				players[this.side].projectiles[this.lane_id].push(new Projectile(this.side, this.lane_id, this.x, -55, [this.currentAttack.maxVelocity * (0.95 + 0.1 * Math.random()), 0.2 + distance / 1000 * -0.5 * (0.95 + 0.1 * Math.random())]))
			}
		}
		if (enemy === undefined || distance > this.preferredRange) {
			if (this.walkFrame < this.anim.attackFrame) {
				this.x += this.speed;
			}
		}
		if (enemy === undefined && this.currentAttack) {
			this.walkFrame = 0;
			this.currentAttack = undefined;
		}
	}
	draw() {
		let coords = getRenderCoords(this.side, this.lane_id, this.x);
		let x = coords[0], y = coords[1], z = coords[2];
		let fw = this.anim.fw, fh = this.anim.fh;
		let mirror = 1, sy = 0;
		let sx = this.walkFrame * fw;
		if (this.side === 1) {
			mirror = -1;
			sy = fh;
			sx = (this.anim.totalFrames - 1) * fw - sx;
		}
		//drawRectangle(gctx, x, y - 70, 40 * (1.0 - 0.4 * (1.0-z)), 70 * (1.0 - 0.4 * (1.0-z)), this.side === 0 ? "red" : "orange")
		gctx.drawImage(this.anim.img, sx, sy, fw, fh, x, y - fh, fw * (1.0 - 0.4 * (1.0-z)) * mirror, fh * (1.0 - 0.4 * (1.0-z)));
		this.walkCounter++;
		if (this.walkCounter > 2) {
			this.walkCounter = 0;
			this.walkFrame++;
			if (this.walkFrame === this.anim.attackFrame) {
				this.walkFrame = 0;
				this.currentAttack = undefined;
				//this.attacking = false;
			} else if (this.currentAttack && this.walkFrame >= this.currentAttack.frame + this.currentAttack.fn) {
				this.walkFrame = 0;
			}
		}
	}
}


class Player {
	constructor(side) {
		this.side = side;
		//increments each tick, couldn't think of a better name
		this.cooldown = 0;
		this.lanes = [[],[],[],[], [],[],[],[]]
		this.projectiles = [[],[],[],[], [],[],[],[]];
		this.isAI = !!side;
		this.selectedLane = 4;
		this.selectedUnit = 0;
		this.chargeProgress = 0;
		this.allUnits = [
			{"img_info":pikeman, "cooldown":80, "speed":15, "attacks":[{"type":"thrust", "maxDamage":20, "range":700, "weight":1, "frame":4, "fn":3}]},
			{"img_info":poleaxer, "cooldown":180, "speed":7, "attacks":[{"type":"cut", "maxDamage":55, "range":800, "weight":1, "frame":4, "fn":4}]},
			{"img_info":bardicher, "cooldown":120, "speed":10, "preferredRange":550, "attacks":[{"type":"thrust", "maxDamage":25, "range":700, "weight":1, "frame":8, "fn":3}, {"type":"cut", "maxDamage":40, "range":550, "weight":2, "frame":4, "fn":3}]},
			{"img_info":archer, "cooldown":120, "speed":7, "preferredRange":5000, "attacks":[{"type":"shoot", "maxVelocity":105, "range":6000, "weight":1, "frame":4, "fn":4}]},
		];
	}
	doAI() {
		//TODO: make this more intelligent
		if (this.cooldown === 0) {
			if (Math.random() < 0.4) {
				this.selectedLane = Math.floor(Math.random() * 8);
			}
			if (Math.random() < 0.5) {
				this.selectedUnit = Math.floor(Math.random() * this.allUnits.length);
			}
		}
	}
}

players = [new Player(0), new Player(1)];
winner = undefined;
/*for (lane_id = 0; lane_id < 8; lane_id++) {
	//bardiche
	players[0].lanes[lane_id].push(new Unit(0, lane_id, 0, 20, 800, poleaxer))
	players[1].lanes[lane_id].push(new Unit(1, lane_id, 0, 30, 700, pikeman))
	players[1].lanes[lane_id].push(new Unit(1, lane_id, -1000, 30, 700, pikeman))
}*/


function tickGame() {
	//blarg
	for (let side = 0; side < 2; side++) {
		let player = players[side];
		player.cooldown += 1;
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lane = player.lanes[lane_id];
			for (let unit_id = 0; unit_id < lane.length; unit_id++) {
				let unit = lane[unit_id];
				unit.tick();
			}
			let projs = player.projectiles[lane_id];
			for (let proj_id = 0; proj_id < projs.length; proj_id++) {
				let projectile = projs[proj_id];
				projectile.tick();
			}
		}
		let unit = player.allUnits[player.selectedUnit];
		if (player.cooldown > unit.cooldown) {
			if (player.chargeProgress >= 20) {
				for (let lane_id = 0; lane_id < 8; lane_id++) {
					player.lanes[lane_id].push(new Unit(side, lane_id, 0, unit));
				}
				player.chargeProgress -= 20;
			} else {
				player.lanes[player.selectedLane].push(new Unit(side, player.selectedLane, 0, unit));
			}
			player.cooldown = 0;
		}
		if (player.isAI) {
			player.doAI();
		}
	}
	if (invasionProgress >= 100) {
		winner = 0;
	} else if (invasionProgress <= 0) {
		winner = 1;
	}
	if (winner !== undefined) {
		let loser_ = players[1 - winner];
		let winner_ = players[winner];
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lanel = loser_.lanes[lane_id].splice(0);
			let lanew = winner_.lanes[lane_id];
			for (let unit_id = lanel.length - 1; unit_id >= 0; unit_id--) {
				let unit = lanel[unit_id];
				unit.x = FIELD_WIDTH - unit.x;
				unit.side = winner;
				lanew.push(unit);
			}
			
		}
	}
}


function drawGame() {
	tickGame();
	drawBattle();
	drawUI();
}


function drawBattle() {
	//basically draws everything when in the main playing mode
	drawRectangle(gctx, 0, 0, gameScreen.width, gameScreen.height, "skyblue")
	drawRectangle(gctx, 0, HORIZON_HEIGHT, gameScreen.width, gameScreen.height, "#4aa02c")
	drawLine(gctx, 0, gameScreen.height, MAX_X_CHANGE, HORIZON_HEIGHT, "yellow");
	drawLine(gctx, gameScreen.width, gameScreen.height, gameScreen.width - MAX_X_CHANGE, HORIZON_HEIGHT, "yellow");
	for (let side = 0; side < 2; side++) {
		let player = players[side];
		let arrow_coords = getRenderCoords(side, player.selectedLane, 0);
		let arrow_x = arrow_coords[0], arrow_y = arrow_coords[1], arrow_z = arrow_coords[2], mirror = (side === 1 ? -1 : 1);
		gctx.drawImage(arrow.img, side * arrow.fw, 0, arrow.fw, arrow.fh, arrow_x, arrow_y - 60 + 20 * arrow_z, mirror * arrow.fw * (1.0 - 0.4 * (1.0-arrow_z)), arrow.fh * (1.0 - 0.4 * (1.0-arrow_z)));
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lane = player.lanes[lane_id];
			for (let unit_id = 0; unit_id < lane.length; unit_id++) {
				let unit = lane[unit_id];
				unit.draw();
			}
			let projs = player.projectiles[lane_id];
			for (let proj_id = 0; proj_id < projs.length; proj_id++) {
				let projectile = projs[proj_id];
				projectile.draw();
			}
		}
	}
}


function drawUI() {
	drawRectangle(gctx, 0, 0, gameScreen.width, 10, "red");
	drawRectangle(gctx, 0, 0, invasionProgress / 100 * gameScreen.width, 10, "green");
	let y = 0;
	for (let side = 0; side < 2; side++) {
		let x = 0;
		let player = players[side];
		for (let i = 0; i < player.allUnits.length; i++) {
			let unit = player.allUnits[i];
			let ii = unit.img_info;
			let x_ = x, sy = 0, sx = 0;
			if (side === 1) {
				x_ = gameScreen.width - x - ii.fw;
				sy = ii.fh;
				sx = (ii.totalFrames - 1) * ii.fw - sx;
			}
			drawRectangle(gctx, x_, y + ii.fh, ii.fw, -ii.fh * player.cooldown / unit.cooldown, "#00000041");
			if (player.selectedUnit === i) drawRectangle(gctx, x_, y, ii.fw, ii.fh, "yellow", true);
			gctx.drawImage(ii.img, sx, sy, ii.fw, ii.fh, x_, y, ii.fw, ii.fh);
			x += ii.fw;
		}
	}
	if (winner !== undefined) {
		let wintext = winner === 1 ? "You Lose" : "You Win";
		drawText(gctx, gameScreen.width/2, gameScreen.height/2, wintext, "white", 150);
	}
}


function mouseUpCanvas(event) {
	heldButtons = event.buttons;
}

function mouseMoveCanvas(event) {
	heldButtons = event.buttons;
	if (event.target.id === "gameScreen") {
		let pos = getMousePos(event);
		if (event.shiftKey || event.ctrlKey) {
			;
		} else {
			if (event.buttons === 1) {
				//paintAt(pos);
			} else if (event.buttons === 2) {
				//paintAt(pos, true);
			}
		}
	}
}

function mouseDownCanvas(event) {
	heldButtons = event.buttons;
	if (event.target.id === "gameScreen") {
		let pos = getMousePos(event);
		if (event.shiftKey || event.ctrlKey) {
			mouseDownPos = pos;
		} else {
			if (event.buttons === 1) {
				//paintAt(pos);
			} else if (event.buttons === 2) {
				//paintAt(pos, true);
			}
		}
	}
}

function contextMenuCanvas(event) {
	//prevent right clicking opening context menu
	//event.preventDefault();
}



function drawLine(ctx, x1, y1, x2, y2, color) {
	ctx.strokeStyle = color;
	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.stroke();
}

function drawRectangle(ctx, x, y, w, h, color, hollow) {
	ctx.fillStyle = color;
	ctx.strokeStyle = color;
	if (hollow) {
		ctx.strokeRect(x,y,w,h);
	} else {
		ctx.fillRect(x,y,w,h);
	}
}

function drawText(ctx, x, y, text, color, size, align) {
	ctx.font = size + "px arial"; 
	ctx.fillStyle = color;
	ctx.textAlign = align || "center";
	ctx.fillText(text, x, y); 
}


function DBP(x1,y1,x2,y2) {
    return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}




</script>
</html>