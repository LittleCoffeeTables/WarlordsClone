<!DOCTYPE html>
<html>
<head>
	<title>Clone of Ben Olding's Warlords</title>
</head>
<!--<body onmousemove="mouseMove(event)" onmousedown="mouseDown()" onmouseup="mouseUp()" onkeydown="pressedKey(event)">-->
<body onkeypress="pressedKey(event)" style="background-color: #232323;">

<img id="pikeman" style="display: none;" src="pikeman2.png">
<img id="poleaxer" style="display: none;" src="poleaxer.png">
<img id="bardicher" style="display: none;" src="bardicher.png">
<img id="archer" style="display: none;" src="archer.png">

<img id="arrow" style="display: none;" src="arrow.png">

<div>
	<canvas id="gameScreen" width="1000" height="570" onmousedown="mouseDownCanvas(event)" onmousemove="mouseMoveCanvas(event)" onmouseup="mouseUpCanvas(event)" oncontextmenu="contextMenuCanvas(event)" onwheel="mouseScroll(event)" />
</div>
<div>
	<p>Music by <a href="https://halfpixel.bandcamp.com/">Half Pixel</a></p>
</div>
<audio id="musics" loop preload="auto">
	<source src="HP_dance_of_the_sands.mp3" type="audio/mp3">
</audio>
<canvas id="c1" width="1000" height="570" style="display: none;" />
<canvas id="c2" width="1000" height="570" style="display: none;" />
<canvas id="c3" width="1000" height="570" style="display: none;" />
<canvas id="c4" width="1000" height="570" style="display: none;" />
<canvas id="c5" width="1000" height="570" style="display: none;" />
<canvas id="c6" width="1000" height="570" style="display: none;" />
<canvas id="c7" width="1000" height="570" style="display: none;" />
<canvas id="c8" width="1000" height="570" style="display: none;" />
<canvas id="c9" width="1000" height="570" style="display: none;" />
<canvas id="c10" width="1000" height="570" style="display: none;" />
<canvas id="c11" width="1000" height="570" style="display: none;" />
<canvas id="c12" width="1000" height="570" style="display: none;" />
<canvas id="c13" width="1000" height="570" style="display: none;" />
<canvas id="c14" width="1000" height="570" style="display: none;" />
<canvas id="c15" width="1000" height="570" style="display: none;" />
<canvas id="c16" width="1000" height="570" style="display: none;" />
<canvas id="c17" width="1000" height="570" style="display: none;" />
<canvas id="c18" width="1000" height="570" style="display: none;" />
<canvas id="c19" width="1000" height="570" style="display: none;" />
<canvas id="c20" width="1000" height="570" style="display: none;" />
<canvas id="c21" width="1000" height="570" style="display: none;" />
<canvas id="c22" width="1000" height="570" style="display: none;" />
<canvas id="c23" width="1000" height="570" style="display: none;" />
<canvas id="c24" width="1000" height="570" style="display: none;" />
<canvas id="c25" width="1000" height="570" style="display: none;" />
<canvas id="c26" width="1000" height="570" style="display: none;" />
<canvas id="c27" width="1000" height="570" style="display: none;" />
<canvas id="c28" width="1000" height="570" style="display: none;" />
<canvas id="c29" width="1000" height="570" style="display: none;" />
<canvas id="c30" width="1000" height="570" style="display: none;" />
<canvas id="c31" width="1000" height="570" style="display: none;" />
<canvas id="c32" width="1000" height="570" style="display: none;" />
<canvas id="c33" width="1000" height="570" style="display: none;" />


<img id="map" style="display: none;" src="map/map.png">
<img id="area1" style="display: none;" src="map/area1.png">
<img id="area2" style="display: none;" src="map/area2.png">
<img id="area3" style="display: none;" src="map/area3.png">
<img id="area4" style="display: none;" src="map/area4.png">
<img id="area5" style="display: none;" src="map/area5.png">
<img id="area6" style="display: none;" src="map/area6.png">
<img id="area7" style="display: none;" src="map/area7.png">
<img id="area8" style="display: none;" src="map/area8.png">
<img id="area9" style="display: none;" src="map/area9.png">
<img id="area10" style="display: none;" src="map/area10.png">
<img id="area11" style="display: none;" src="map/area11.png">
<img id="area12" style="display: none;" src="map/area12.png">
<img id="area13" style="display: none;" src="map/area13.png">
<img id="area14" style="display: none;" src="map/area14.png">
<img id="area15" style="display: none;" src="map/area15.png">
<img id="area16" style="display: none;" src="map/area16.png">
<img id="area17" style="display: none;" src="map/area17.png">
<img id="area18" style="display: none;" src="map/area18.png">
<img id="area19" style="display: none;" src="map/area19.png">
<img id="area20" style="display: none;" src="map/area20.png">
<img id="area21" style="display: none;" src="map/area21.png">
<img id="area22" style="display: none;" src="map/area22.png">
<img id="area23" style="display: none;" src="map/area23.png">
<img id="area24" style="display: none;" src="map/area24.png">
<img id="area25" style="display: none;" src="map/area25.png">
<img id="area26" style="display: none;" src="map/area26.png">
<img id="area27" style="display: none;" src="map/area27.png">
<img id="area28" style="display: none;" src="map/area28.png">
<img id="area29" style="display: none;" src="map/area29.png">
<img id="area30" style="display: none;" src="map/area30.png">
<img id="area31" style="display: none;" src="map/area31.png">
<img id="area32" style="display: none;" src="map/area32.png">
<img id="area33" style="display: none;" src="map/area33.png">


</body>
<style id="theStyle" type="text/css">
	div {
		text-align: center;
	}
	canvas {
		border: 1px dashed red;
	}
</style>
<script type="text/javascript">

var gameScreen = document.getElementById("gameScreen");
var gctx = gameScreen.getContext("2d");
var hoveredArea = undefined;

var mouseDownPos = undefined;
var heldButtons = 0;
const MAX_BATTLE_DURATION = 5 * 60 * 30; //5 minutes
var players, invasionProgress, battleTimer, winner, currentArea;
var gameState, races, playerRaces, invadableAreas;
const SHOP = {UPGRADE:{w:800,h:400}, HOTBAR:{w:800,h:100}, EQUIP:{w:100,h:500}, BUY:{w:100,h:500}}
var shop = {};

//total pixel change in starting x over all 8 lanes
const MAX_X_CHANGE = 150;
const HORIZON_HEIGHT = 150;
const FIELD_WIDTH = 10000;
const FIELD_HEIGHT = 200;
const Z_PER_LANE = [0, 0.11, 0.23, 0.36, 0.50, 0.65, 0.81, 0.98];

const pikeman = {"img":document.getElementById("pikeman"), "fw":100, "fh":100, "attackFrame":4, "frames":7, "totalFrames":10};
const poleaxer = {"img":document.getElementById("poleaxer"), "fw":100, "fh":100, "attackFrame":4, "frames":8, "totalFrames":10};
const bardicher = {"img":document.getElementById("bardicher"), "fw":100, "fh":100, "attackFrame":4, "frames":11, "totalFrames":11};
const archer = {"img":document.getElementById("archer"), "fw":100, "fh":100, "attackFrame":4, "frames":8, "totalFrames":11};

const arrow = {"img":document.getElementById("arrow"), "fw":88, "fh":61};
const map_img = {"img":document.getElementById("map"), "fw":1000, "fh":570};


const adjacent_areas = {
	1:[2,12,13], 2:[1,3,7,11,12], 3:[2,4,6,7], 4:[3,5,6], 5:[4,6,8,14], 6:[3,4,5,7,8],
	7:[2,3,6,8,9,11], 8:[5,6,7,9,22], 9:[7,8,10,11,23], 10:[9,11,24], 11:[2,7,9,10,12],
	12:[1,2,11,13], 13:[1,12], 14:[5,15,20,21,22], 15:[14,16,19,20], 16:[15,17,18,19],
	17:[16,18,32], 18:[16,17,19,32], 19:[15,16,18,20,32,33], 20:[14,15,19,21,29,33],
	21:[14,20,22,23,28,29], 22:[8,14,21,23], 23:[9,21,22,24,28], 24:[10,23,25,28],
	25:[24,26,27,28], 26:[25,27,31], 27:[25,26,28,30,31], 28:[21,23,24,25,27,29,30],
	29:[20,21,28,30,31,32,33], 30:[27,28,29,31], 31:[26,27,29,30,32], 32:[17,18,19,29,31,33],
	33:[19,20,29,32]
}
const area_centres = {
	1:[65,400], 2:[230,425], 3:[290,350], 4:[345,235], 5:[475,230], 6:[410,290], 7:[390,390],
	8:[490,350], 9:[475,460], 10:[495,540], 11:[315,535], 12:[160,495], 13:[50,540], 14:[620,170],
	15:[725,75], 16:[840,55], 17:[960,75], 18:[910,135], 19:[825,175], 20:[735,190], 21:[695,290],
	22:[615,305], 23:[625,420], 24:[640,520], 25:[785,545], 26:[950,530], 27:[860,475], 28:[745,445],
	29:[790,305], 30:[875,380], 31:[980,370], 32:[945,230], 33:[825,245]
}





window.onload = function() {
	//blarg
	initGame();
	window.setInterval(drawGame, 1000/30);
	//drawGame()
}

function remove(array, item) {
	for (let i = array.length - 1; i >= 0; i--) {
		if (item === array[i]) array.splice(i, 1);
	}
}

function isArray(a) {
	return (Object.prototype.toString.call(a) === "[object Array]");
}
function isObject(a) {
	return (Object.prototype.toString.call(a) === "[object Object]");
}



function pressedKey(event) {
	//console.log(event)
	if (event.code === "KeyM") {
		//note - this is special because it activates anywhere
		let musics = document.getElementById("musics");
		musics.volume = (musics.volume === 0.4 ? 0.1 : 0.4);
	}
	if (gameState === "battle") {
		let player_right = 1 - players[1].isAI, mirror = (player_right === 1 ? -1 : 1);
		if (event.code === "KeyS") {
			players[0].selectedLane++;
			if (players[0].selectedLane > 7) players[0].selectedLane = 0;
		} else if (event.code === "KeyW") {
			players[0].selectedLane--;
			if (players[0].selectedLane < 0) players[0].selectedLane = 7;
		} else if (event.code === "KeyA") {
			players[0].preparedToCharge = false;
			players[0].selectedUnit--;
			if (players[0].selectedUnit < 0) players[0].selectedUnit = players[0].allUnits.length - 1;
		} else if (event.code === "KeyD") {
			players[0].preparedToCharge = false;
			players[0].selectedUnit++;
			if (players[0].selectedUnit >= players[0].allUnits.length) players[0].selectedUnit = 0;
		} else if (event.key === "ArrowDown") {
			players[player_right].selectedLane++;
			if (players[player_right].selectedLane > 7) players[player_right].selectedLane = 0;
		} else if (event.key === "ArrowUp") {
			players[player_right].selectedLane--;
			if (players[player_right].selectedLane < 0) players[player_right].selectedLane = 7;
		} else if (event.key === "ArrowLeft") {
			players[player_right].preparedToCharge = false;
			players[player_right].selectedUnit -= mirror;
			if (players[player_right].selectedUnit >= players[player_right].allUnits.length) {
				players[player_right].selectedUnit = 0;
			} else if (players[player_right].selectedUnit < 0) {
				players[player_right].selectedUnit = players[player_right].allUnits.length - 1;
			}
		} else if (event.key === "ArrowRight") {
			players[player_right].preparedToCharge = false;
			players[player_right].selectedUnit += mirror;
			if (players[player_right].selectedUnit >= players[player_right].allUnits.length) {
				players[player_right].selectedUnit = 0;
			} else if (players[player_right].selectedUnit < 0) {
				players[player_right].selectedUnit = players[player_right].allUnits.length - 1;
			}
		} else if (event.code === "KeyQ") {
			if (players[0].chargeProgress >= 20) players[0].preparedToCharge = true;
		} else if (event.key === "Enter") {
			if (players[player_right].chargeProgress >= 20) players[player_right].preparedToCharge = true;
		} else if (event.key === "Escape") {
			//surrender for now, later bring up pause menu
			initMap();
		} /*else {
			console.log(event);
		}*/
	} else if (gameState === "race_selector") {
		if (event.code === "KeyA" || event.key === "ArrowLeft") {
			playerRaces[0]--;
			if (playerRaces[0] < 0) playerRaces[0] = races.length - 1;
		} else if (event.code === "KeyD" || event.key === "ArrowRight") {
			playerRaces[0]++;
			if (playerRaces[0] >= races.length) playerRaces[0] = 0;
		} else if (event.key === "Enter") {
			initShop();
			let musics = document.getElementById("musics");
			musics.volume = 0.4;
			musics.play();
		}
	} else if (gameState === "shop") {
		if (event.key === "Escape") {
			gameState = "map";
		}
	} else if (gameState === "map") {
		if (event.key === "Escape") {
			gameState = "shop";
		}
	}
}

function getMousePos(event) {
	var bb = event.target.getBoundingClientRect();
	return [event.clientX - bb.left, event.clientY - bb.top];
}

function mouseMove(event) {
	//stuff
	getMousePos(event);
}

function mouseDown() {
	//stuff
	//maybe for drawing lines?
	/*mouseDownPos[0] = mousePos[0];
	mouseDownPos[1] = mousePos[1];*/
}


function getFirstEnemy(side, lane_id, x, range) {
	let lane = players[1 - side].lanes[lane_id];
	let closest_enemy = undefined;
	let closest_distance = Infinity;
	for (let unit_id = 0; unit_id < lane.length; unit_id++) {
		let unit = lane[unit_id];
		let distance = FIELD_WIDTH - unit.x - x
		if (distance > 0 && distance < closest_distance && distance < range) {
			closest_enemy = unit;
			closest_distance = distance;
		}
	}
	return closest_enemy;
}
function getRenderCoords(side, lane_id, x) {
	let z = Z_PER_LANE[lane_id];
	let x_offset = (1.0 - z) * MAX_X_CHANGE;
	let max_x = gameScreen.width - x_offset * 2;
	let apparent_x = x * max_x / FIELD_WIDTH + x_offset;
	if (side === 1) apparent_x = gameScreen.width - apparent_x;
	let apparent_y = FIELD_HEIGHT + z * (gameScreen.height - FIELD_HEIGHT);
	return [apparent_x, apparent_y, z];
}


class Projectile {
	//assumed arrow
	constructor(side, lane_id, x, y, velocity) {
		this.side = side;
		this.lane_id = lane_id;
		this.x = x;
		this.y = y;
		this.velocity = velocity;
	}
	tick() {
		let enemy = getFirstEnemy(this.side, this.lane_id, this.x, this.velocity[0]);
		this.x += this.velocity[0];
		this.y += this.velocity[1];
		this.velocity[0] *= 0.99;
		this.velocity[1] += 0.08;
		if (enemy !== undefined && this.y > -70 && this.y < -10) {
			let speed = DBP(0,0, this.velocity[0], this.velocity[1]);
			enemy.takeDamage("thrust", speed / 19, 0.0);
			remove(players[this.side].projectiles[this.lane_id], this)
		}
		if (this.y > 0) remove(players[this.side].projectiles[this.lane_id], this);
	}
	draw() {
		let coords = getRenderCoords(this.side, this.lane_id, this.x);
		let x = coords[0], y = coords[1], z = coords[2];
		//console.log("arrow", x, y, z, this.y, this.velocity);
		let mirror = this.side === 1 ? -1 : 1;
		drawLine(gctx, x, y + this.y + 15 * z, x + mirror * 20 * (1.0 - 0.4 * (1.0-z)), y + this.y + 15 * z + this.velocity[1] * (1.0 - 0.4 * (1.0-z)), "black");
		//gctx.drawImage(this.anim.img, sx, sy, fw, fh, x, y - fh, fw * (1.0 - 0.4 * (1.0-z)) * mirror, fh * (1.0 - 0.4 * (1.0-z)));
	}
}


class Unit {
	constructor(side, lane_id, x, unit) {
		this.side = side;
		this.lane_id = lane_id;
		this.x = x;
		this.health = 100;
		this.thrustResist = unit.thrustResist || 0;
		this.cutResist = unit.cutResist || 0;
		this.bluntResist = unit.bluntResist || 0;
		this.magicResist = unit.magicResist || 0;
		this.attacks = unit.attacks;
		//maybe change it so all attacks are checked through for the highest range?
		this.maxRange = unit.attacks[0].range;
		this.preferredRange = unit.preferredRange || this.maxRange;
		//speed should be roughly 6 times as high as in Warlords: Call to Arms eg. 5 * 6 = 30 for a pikeman
		this.speed = unit.speed * (0.9 + 0.2 * Math.random());
		this.walkFrame = 0;
		this.walkCounter = 0;
		this.currentAttack;
		this.anim = unit.img_info;
	}
	//WHY the fuck is piercing not dependent on the dealer?
	takeDamage(type, amount, piercing) {
		if (type === "thrust") {
			amount *= (1 - this.thrustResist * (1 - piercing) );
		}
		this.health -= amount;
		if (this.health < 0) {
			remove(players[this.side].lanes[this.lane_id], this);
			players[1 - this.side].chargeProgress += 1;
		}
	}
	tick() {
		if (this.x > FIELD_WIDTH) {
			remove(players[this.side].lanes[this.lane_id], this);
			invasionProgress += (this.side === 0 ? 1 : -1);
		}
		let enemy = getFirstEnemy(this.side, this.lane_id, this.x, this.maxRange);
		let distance = Infinity;
		if (enemy !== undefined) {
			distance = Math.abs(this.x + enemy.x - FIELD_WIDTH);
			if (!this.currentAttack) {
				let potential_attacks = [];
				let total_weight = 0;
				for (let i = 0; i < this.attacks.length; i++) {
					//console.log("blarg", this.attacks.length, this.maxRange, distance, this.attacks[i].range);
					if (distance <= this.attacks[i].range) {
						//if (this.attacks.length === 1) console.log("blarg")
						potential_attacks.push(this.attacks[i]);
						total_weight += this.attacks[i].weight;
					}
				}
				if (potential_attacks.length === 0) {
					console.log("weirdness", this.attacks.length);
					return;
				}
				let choice = total_weight * Math.random();
				let attack;
				for (let i = 0; i < potential_attacks.length; i++) {
					attack = potential_attacks[i];
					choice -= attack.weight;
					if (choice < 0) {
						break;
					}
				}
				//console.log(enemy)
				//console.log(attack)
				this.currentAttack = attack;
				this.walkFrame = attack.frame;
			}
			if (this.currentAttack.type !== "shoot" && this.walkFrame === this.currentAttack.frame && this.walkCounter === 1) {
				//wth is up with piercing being hardcoded
				enemy.takeDamage(this.currentAttack.type, this.currentAttack.maxDamage * (0.8 + 0.2 * Math.random()), 0.4)
			} else if (this.currentAttack.type === "shoot" && this.walkFrame === this.currentAttack.frame + this.currentAttack.fn - 1 && this.walkCounter === 1) {
				//launch projectile
				players[this.side].projectiles[this.lane_id].push(new Projectile(this.side, this.lane_id, this.x, -55, [this.currentAttack.maxVelocity * (0.95 + 0.1 * Math.random()), 0.2 + distance / 1000 * -0.5 * (0.95 + 0.1 * Math.random())]))
			}
		}
		if (enemy === undefined || distance > this.preferredRange) {
			if (this.walkFrame < this.anim.attackFrame) {
				this.x += this.speed;
			}
		}
		if (enemy === undefined && this.currentAttack) {
			this.walkFrame = 0;
			this.currentAttack = undefined;
		}
	}
	draw() {
		let coords = getRenderCoords(this.side, this.lane_id, this.x);
		let x = coords[0], y = coords[1], z = coords[2];
		let fw = this.anim.fw, fh = this.anim.fh;
		let mirror = 1, sy = 0;
		let sx = this.walkFrame * fw;
		if (this.side === 1) {
			mirror = -1;
			sy = fh;
			sx = (this.anim.totalFrames - 1) * fw - sx;
		}
		//drawRectangle(gctx, x, y - 70, 40 * (1.0 - 0.4 * (1.0-z)), 70 * (1.0 - 0.4 * (1.0-z)), this.side === 0 ? "red" : "orange")
		gctx.drawImage(this.anim.img, sx, sy, fw, fh, x, y - fh, fw * (1.0 - 0.4 * (1.0-z)) * mirror, fh * (1.0 - 0.4 * (1.0-z)));
		this.walkCounter++;
		if (this.walkCounter > 2) {
			this.walkCounter = 0;
			this.walkFrame++;
			if (this.walkFrame === this.anim.attackFrame) {
				this.walkFrame = 0;
				this.currentAttack = undefined;
				//this.attacking = false;
			} else if (this.currentAttack && this.walkFrame >= this.currentAttack.frame + this.currentAttack.fn) {
				this.walkFrame = 0;
			}
		}
	}
}


class Player {
	constructor(side, army) {
		this.side = side;
		//increments each tick, couldn't think of a better name
		this.cooldown = 0;
		this.lanes = [[],[],[],[], [],[],[],[]]
		this.projectiles = [[],[],[],[], [],[],[],[]];
		this.isAI = !!side;
		this.selectedLane = 4;
		this.selectedUnit = 0;
		this.chargeProgress = 0;
		this.preparedToCharge = false;
		this.allUnits = army || [
			{"img_info":pikeman, "cooldown":80, "speed":15, "attacks":[{"type":"thrust", "maxDamage":20, "range":700, "weight":1, "frame":4, "fn":3}]},
			{"img_info":poleaxer, "cooldown":180, "speed":7, "thrustResist":0.3, "attacks":[{"type":"cut", "maxDamage":55, "range":800, "weight":1, "frame":4, "fn":4}]},
			{"img_info":bardicher, "cooldown":120, "speed":10, "preferredRange":550, "thrustResist":0.3, "attacks":[{"type":"thrust", "maxDamage":25, "range":700, "weight":1, "frame":8, "fn":3}, {"type":"cut", "maxDamage":40, "range":550, "weight":2, "frame":4, "fn":3}]},
			{"img_info":archer, "cooldown":120, "speed":7, "preferredRange":5000, "attacks":[{"type":"shoot", "maxVelocity":105, "range":6000, "weight":1, "frame":4, "fn":4}]},
		];
	}
	doAI() {
		//TODO: make this more intelligent
		if (this.cooldown === 0) {
			if (Math.random() < 0.4) {
				this.selectedLane = Math.floor(Math.random() * 8);
			}
			if (Math.random() < 0.5) {
				this.selectedUnit = Math.floor(Math.random() * this.allUnits.length);
			}
		}
	}
}



/*for (lane_id = 0; lane_id < 8; lane_id++) {
	//bardiche
	players[0].lanes[lane_id].push(new Unit(0, lane_id, 0, 20, 800, poleaxer))
	players[1].lanes[lane_id].push(new Unit(1, lane_id, 0, 30, 700, pikeman))
	players[1].lanes[lane_id].push(new Unit(1, lane_id, -1000, 30, 700, pikeman))
}*/


function tickGame() {
	if (battleTimer > 0) battleTimer--;
	for (let side = 0; side < 2; side++) {
		let player = players[side];
		player.cooldown += 1;
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lane = player.lanes[lane_id];
			for (let unit_id = 0; unit_id < lane.length; unit_id++) {
				let unit = lane[unit_id];
				unit.tick();
			}
			let projs = player.projectiles[lane_id];
			for (let proj_id = 0; proj_id < projs.length; proj_id++) {
				let projectile = projs[proj_id];
				projectile.tick();
			}
		}
		let unit = player.allUnits[player.selectedUnit];
		if (winner === undefined && player.cooldown > unit.cooldown) {
			if (player.chargeProgress >= 20 && (player.preparedToCharge || player.isAI)) {
				for (let lane_id = 0; lane_id < 8; lane_id++) {
					player.lanes[lane_id].push(new Unit(side, lane_id, 0, unit));
				}
				player.chargeProgress -= 20;
				player.preparedToCharge = false;
			} else {
				player.lanes[player.selectedLane].push(new Unit(side, player.selectedLane, 0, unit));
			}
			player.cooldown = 0;
		}
		if (player.isAI) {
			player.doAI();
		}
	}
	let timerBonus = 49 * (battleTimer <= 0);
	if (invasionProgress >= 100 - timerBonus) {
		winner = 0;
	} else if (invasionProgress <= 0 + timerBonus) {
		winner = 1;
	}
	if (winner !== undefined) {
		let loser_ = players[1 - winner];
		let winner_ = players[winner];
		if (winner_.cooldown > 200) {
			endMatch();
		}
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lanel = loser_.lanes[lane_id].splice(0);
			let lanew = winner_.lanes[lane_id];
			for (let unit_id = lanel.length - 1; unit_id >= 0; unit_id--) {
				let unit = lanel[unit_id];
				unit.x = FIELD_WIDTH - unit.x;
				unit.side = winner;
				lanew.push(unit);
			}
		}
	}
}


function endMatch() {
	if (winner === 0) {
		races[playerRaces[winner]].areas.push(currentArea);
		races[playerRaces[1 - winner]].areas.splice(races[playerRaces[1 - winner]].areas.indexOf(currentArea), 1);
		let area = document.getElementById("area"+currentArea);
		let canvas = document.getElementById("c"+currentArea);
		let ctx = canvas.getContext("2d");
		ctx.globalCompositeOperation = "source-over";
		ctx.drawImage(area, 0, 0, map_img.fw, map_img.fh);
		ctx.globalCompositeOperation = "source-in";
		drawRectangle(ctx, 0, 0, map_img.fw, map_img.fh, races[playerRaces[winner]].colour);
		shop.funds += 300;
	} else {
		shop.funds += 100;
	}
	initMap();
	currentArea = undefined;
}

function initMatch(area) {
	let player_army = [];
	for (let i = 0; i < shop.equippedUnits.length; i++) {
		player_army.push(shop.boughtUnits[shop.equippedUnits[i]]);
	}
	players = [new Player(0, player_army), new Player(1)];
	invasionProgress = 50;
	winner = undefined;
	gameState = "battle";
	currentArea = area;
	battleTimer = MAX_BATTLE_DURATION;
}

function initGame() {
	gameState = "race_selector";
	races = [
		new Race("Seagull People", "#f2ea6c", [14,15,16]),
		new Race("Pink Orcs", "#c954d3", [6,7,8]),
		new Race("Humans", "#411ef0", [19,20,33]),
		new Race("Cave Trolls", "#1f6460", [29,30,31]),
		new Race("Mountain Trolls", "#47c6bf", [25,26,27]),
		new Race("River Orcs", "#f6267e", [21,22,28]),
		new Race("Frog People", "#1bbd6b", [10,23,24]),
		new Race("Plant People", "#417721", [9,11,12]),
		new Race("Demons", "#d40c40", [17,18,32]),
		new Race("Fish People", "#2cb1e2", [3,4,5]),
		new Race("Lizardmen", "#db9930", [1,2,13])
	];
	let w = map_img.fw, h = map_img.fh;
	for (let race_id = 0; race_id < races.length; race_id++) {
		let race = races[race_id];
		for (let i = 0; i < race.areas.length; i++) {
			let area_id = race.areas[i];
			let area = document.getElementById("area"+area_id);
			let canvas = document.getElementById("c"+area_id);
			let ctx = canvas.getContext("2d");
			ctx.globalCompositeOperation = "source-over";
			ctx.drawImage(area, 0, 0, w, h);
			ctx.globalCompositeOperation = "source-in";
			drawRectangle(ctx, 0, 0, w, h, race.colour);
		}
	}
	playerRaces = [2];
}

function initShop() {
	shop.equippedUnits = ["pikeman","poleaxer"];
	shop.boughtUnits = [];
	shop.funds = 500;
	shop.displayedUnit = undefined;
	shop.equipOffset = 0;
	shop.buyOffset = 0;
	shop.availableUnits = {
		pikeman:{id:"pikeman", name:"Pikeman", "img_info":pikeman, "cooldown":80, "price":300, "speed":15, "attacks":[{"type":"thrust", "maxDamage":20, "range":700, "weight":1, "frame":4, "fn":3}]},
		poleaxer:{id:"poleaxer", name:"Poleaxer", "img_info":poleaxer, "cooldown":180, "price":400, "speed":7, "thrustResist":0.3, "attacks":[{"type":"cut", "maxDamage":55, "range":800, "weight":1, "frame":4, "fn":4}]},
		bardicher:{id:"bardicher", name:"Bardicher", "img_info":bardicher, "cooldown":120, "price":400, "speed":10, "preferredRange":550, "thrustResist":0.3, "attacks":[{"type":"thrust", "maxDamage":25, "range":700, "weight":1, "frame":8, "fn":3}, {"type":"cut", "maxDamage":40, "range":550, "weight":2, "frame":4, "fn":3}]},
		archer:{id:"archer", name:"Archer", "img_info":archer, "cooldown":120, "price":500, "speed":7, "preferredRange":5000, "attacks":[{"type":"shoot", "maxVelocity":105, "range":6000, "weight":1, "frame":4, "fn":4}]},
	};
	for (let i = 0; i < shop.equippedUnits.length; i++) {
		let unit_name = shop.equippedUnits[i];
		shop.boughtUnits[unit_name] = shop.availableUnits[unit_name];
		shop.boughtUnits[unit_name].bought = true;
		delete shop.availableUnits[unit_name];
	}
	initMap();
}

function initMap() {
	let race = races[playerRaces[0]];
	invadableAreas = {};
	for (let i = 0; i < race.areas.length; i++) {
		let area_id = race.areas[i], centre = area_centres[area_id];
		let adjs = adjacent_areas[area_id];
		for (let adjacent = 0; adjacent < adjs.length; adjacent++) {
			let other_area_id = adjs[adjacent];
			if (race.areas.indexOf(other_area_id) === -1) {
				let other_centre = area_centres[other_area_id];
				let distance = DBP(centre[0], centre[1], other_centre[0], other_centre[1]);
				if (invadableAreas[other_area_id] === undefined || invadableAreas[other_area_id][1] > distance) {
					invadableAreas[other_area_id] = [area_id, distance];
				}
			}
		}
	}
	gameState = "shop";
}


class Race {
	constructor(name, colour, areas) {
		this.name = name;
		this.colour = colour;
		this.areas = areas;
	}
}


function drawGame() {
	if (gameState === "battle") {
		tickGame();
		drawBackground();
		drawUI();
		drawBattle();
	} else if (gameState === "map") {
		drawMap();
	} else if (gameState === "race_selector") {
		drawSelector();
	} else if (gameState === "shop") {
		drawShop();
	}
}


function drawSelector() {
	drawRectangle(gctx, gameScreen.width/3, gameScreen.height/3, gameScreen.width/3, gameScreen.height/3, races[playerRaces[0]].colour);
	drawText(gctx, gameScreen.width/2, 30, "A and D or left and right arrow to change race", "white", "30");
	drawText(gctx, gameScreen.width/2, 60, "Enter to select", "white", "30");
	drawText(gctx, gameScreen.width/2, gameScreen.height/2, races[playerRaces[0]].name, "black", "30");
}


function drawShop() {
	drawRectangle(gctx, 0, 0, gameScreen.width, gameScreen.height, "#453423");
	drawUpgrades(0, 0, SHOP.UPGRADE.w, SHOP.UPGRADE.h);
	drawHotbar(0, gameScreen.height - SHOP.HOTBAR.h, SHOP.HOTBAR.w, SHOP.HOTBAR.h);
	drawEquiplist(SHOP.UPGRADE.w, 0, SHOP.EQUIP.w, SHOP.EQUIP.h);
	drawBuylist(gameScreen.width - SHOP.BUY.w, 0, SHOP.BUY.w, SHOP.BUY.h);
	drawRectangleWithText(gctx, SHOP.HOTBAR.w, SHOP.BUY.h, 200, 70, "green", "Done", "black", 30);
	drawText(gctx, 100, SHOP.UPGRADE.h + 35, "Money: "+shop.funds, "white", 30);
}
function drawUpgrades(x, y, w, h) {
	drawText(gctx, x + w/2, y + h/4, "Upgrades", "white", 50);
	if (shop.displayedUnit !== undefined) {
		drawText(gctx, x + w/2, y + h/3, shop.displayedUnit.name, "white", 30);
		let text;
		if (shop.displayedUnit.bought) {
			if (shop.equippedUnits.indexOf(shop.displayedUnit.id) === -1) {
				text = "Equip";
			} else {
				text = "Unequip";
			}
		} else {
			text = "Buy for " + shop.displayedUnit.price
		}
		drawRectangleWithText(gctx, x + w - 200, y + h, 200, 50, "blue", text, "black", 30);
	}
}
function drawHotbar(x, y, w, h) {
	drawText(gctx, x + w/2, y + h/2, "HOTBAR", "white", 20);
	drawRectangle(gctx, x,y, w,h, "red", true);
	for (let i = 0; i < shop.equippedUnits.length; i++) {
		let unit = shop.boughtUnits[shop.equippedUnits[i]];
		gctx.drawImage(unit.img_info.img, 0,0, 100,100, x+100*i,y, 100,100);
	}
}
function drawEquiplist(x, y, w, h) {
	drawText(gctx, x + w/2, y + h/2, "EQUIP", "white", 20);
	drawRectangle(gctx, x,y, w,h, "red", true);
	let keys = Object.keys(shop.boughtUnits);
	for (let i = 0; i < keys.length; i++) {
		let unit = shop.boughtUnits[keys[i]];
		gctx.drawImage(unit.img_info.img, 0,0, 100,100, x,y+100*i, 100,100);
		if (shop.equippedUnits.indexOf(keys[i]) >= 0) {
			drawRectangle(gctx, x, y + 100*i, 10, 10, "green");
		}
	}
}
function drawBuylist(x, y, w, h) {
	drawText(gctx, x + w/2, y + h/2, "BUY", "white", 20);
	drawRectangle(gctx, x,y, w,h, "red", true);
	let keys = Object.keys(shop.availableUnits);
	for (let i = 0; i < keys.length; i++) {
		let unit = shop.availableUnits[keys[i]];
		gctx.drawImage(unit.img_info.img, 0,0, 100,100, x,y+100*i, 100,100);
	}
}


function drawMap() {
	let w = map_img.fw, h = map_img.fh;
	gctx.drawImage(map_img.img, 0, 0);
	for (let area_id = 1; area_id < 34; area_id++) {
		let area = document.getElementById("c"+area_id);
		//console.log(area, "area"+area_id);
		if (area_id === hoveredArea) gctx.globalAlpha = 0.7;
		gctx.drawImage(area, 0, 0);
		gctx.globalAlpha = 1.0;
	}
	for (let area_id = 1; area_id < 34; area_id++) {
		if (invadableAreas[area_id] !== undefined) {
			let centre = area_centres[area_id];
			let other_centre = area_centres[invadableAreas[area_id][0]];
			drawLine(gctx, centre[0], centre[1], other_centre[0], other_centre[1], "black");
		}
	}
}


function drawBattle() {
	for (let side = 0; side < 2; side++) {
		let player = players[side];
		for (let lane_id = 0; lane_id < 8; lane_id++) {
			let lane = player.lanes[lane_id];
			for (let unit_id = 0; unit_id < lane.length; unit_id++) {
				let unit = lane[unit_id];
				unit.draw();
			}
			let projs = player.projectiles[lane_id];
			for (let proj_id = 0; proj_id < projs.length; proj_id++) {
				let projectile = projs[proj_id];
				projectile.draw();
			}
		}
	}
}

function drawBackground() {
	drawRectangle(gctx, 0, 0, gameScreen.width, gameScreen.height, "skyblue")
	drawRectangle(gctx, 0, HORIZON_HEIGHT, gameScreen.width, gameScreen.height, "#4aa02c")
	drawLine(gctx, 0, gameScreen.height, MAX_X_CHANGE, HORIZON_HEIGHT, "yellow");
	drawLine(gctx, gameScreen.width, gameScreen.height, gameScreen.width - MAX_X_CHANGE, HORIZON_HEIGHT, "yellow");
}


function drawUI() {
	drawRectangle(gctx, 0, 0, gameScreen.width, 10, races[playerRaces[1]].colour);
	drawRectangle(gctx, 0, 0, invasionProgress / 100 * gameScreen.width, 10, races[playerRaces[0]].colour);
	let y = 0;
	for (let side = 0; side < 2; side++) {
		let x = 0;
		let player = players[side];
		let arrow_coords = getRenderCoords(side, player.selectedLane, 0);
		let arrow_x = arrow_coords[0], arrow_y = arrow_coords[1], arrow_z = arrow_coords[2], mirror = (side === 1 ? -1 : 1);
		gctx.drawImage(arrow.img, side * arrow.fw, 0, arrow.fw, arrow.fh, arrow_x, arrow_y - 60 + 20 * arrow_z, mirror * arrow.fw * (1.0 - 0.4 * (1.0-arrow_z)), arrow.fh * (1.0 - 0.4 * (1.0-arrow_z)));
		for (let i = 0; i < player.allUnits.length; i++) {
			let unit = player.allUnits[i];
			let ii = unit.img_info;
			let x_ = x, sy = 0, sx = 0;
			if (side === 1) {
				x_ = gameScreen.width - x - ii.fw;
				sy = ii.fh;
				sx = (ii.totalFrames - 1) * ii.fw - sx;
			}
			let w = ii.fw * 0.5, h = ii.fh * 0.5;
			let colour = (player.preparedToCharge && player.selectedUnit === i ? "#f0000041" : "#00000041");
			drawRectangle(gctx, x_, y + h, w, -h * player.cooldown / unit.cooldown, colour);
			if (player.selectedUnit === i) drawRectangle(gctx, x_, y, w, h, "yellow", true);
			gctx.drawImage(ii.img, sx, sy, ii.fw, ii.fh, x_, y, w, h);
			x += w;
		}
	}
	if (players[0].chargeProgress >= 20) {
		drawText(gctx, 0, 60, "Ready to charge", "red", 20, "left");
	}
	drawCircle(gctx, gameScreen.width/2, 60, 50, "#444444", 1 - battleTimer/MAX_BATTLE_DURATION);
	if (battleTimer < 30 * 60) {
		drawText(gctx, gameScreen.width/2, 60, Math.floor(battleTimer/30), "white", 60);
	}
	if (winner !== undefined) {
		let wintext = winner === 1 ? "You Lose" : "You Win";
		drawText(gctx, gameScreen.width/2, gameScreen.height/2, wintext, "white", 150);
	}
}

function getAreaOwnerId(area_id) {
	for (let race_id = 0; race_id < races.length; race_id++) {
		let race = races[race_id];
		for (let i = 0; i < race.areas.length; i++) {
			if (race.areas[i] === area_id) {
				return race_id;
			}
		}
	}
}

function getClickedArea(pos) {
	let w = map_img.fw, h = map_img.fh;
	for (let area_id = 1; area_id < 34; area_id++) {
		let area = document.getElementById("c"+area_id);
		let ctx = area.getContext("2d");
		let data = ctx.getImageData(pos[0], pos[1], 1,1).data;
		if (data[3] !== 0) return area_id;
	}
}
function getClickedSection(pos) {
	if (pos[0] > SHOP.HOTBAR.w && pos[1] > SHOP.BUY.h) {
		return ["EXIT", pos];
	}
	if (pos[0] < SHOP.UPGRADE.w && pos[1] < SHOP.UPGRADE.h) {
		return ["UPGRADE", pos];
	} else if (pos[0] < SHOP.HOTBAR.w && pos[1] > gameScreen.height - SHOP.HOTBAR.h) {
		return ["HOTBAR", [pos[0], pos[1] - gameScreen.height + SHOP.HOTBAR.h]];
	} else if (pos[0] > SHOP.UPGRADE.w) {
		if (pos[0] < SHOP.UPGRADE.w + SHOP.EQUIP.w) {
			return ["EQUIP", [pos[0] - SHOP.UPGRADE.w, pos[1]]];
		} else if (pos[0] > gameScreen.width - SHOP.BUY.w) {
			return ["BUY", [pos[0] - gameScreen.width + SHOP.BUY.w, pos[1]]];
		}
	} else {
		return ["NONE", pos];
	}
}
function handleShopClick(subscreen, new_pos) {
	if (subscreen === "EXIT") {
		gameState = "map";
	} else if (subscreen === "HOTBAR") {
		let i = Math.floor(new_pos[0]/100);
		if (i < shop.equippedUnits.length) {
			shop.displayedUnit = shop.boughtUnits[shop.equippedUnits[i]];
		}
	} else if (subscreen === "EQUIP") {
		let i = Math.floor(new_pos[1]/100);
		let keys = Object.keys(shop.boughtUnits);
		if (i < keys.length) {
			shop.displayedUnit = shop.boughtUnits[keys[i]];
		}
	} else if (subscreen === "BUY") {
		let i = Math.floor(new_pos[1]/100);
		let keys = Object.keys(shop.availableUnits);
		if (i < keys.length) {
			shop.displayedUnit = shop.availableUnits[keys[i]];
		}
	} else if (subscreen === "UPGRADE") {
		//blarg
	} else if (subscreen === "NONE") {
		if (shop.displayedUnit !== undefined && new_pos[0] > SHOP.UPGRADE.w - 200 && new_pos[0] < SHOP.UPGRADE.w && new_pos[1] > SHOP.UPGRADE.h && new_pos[1] < SHOP.UPGRADE.h + 50) {
			//currently, we store the unit object. Would it be better to store the unit's id instead and always check whether it's in the keys of boughtUnits or availableUnits?
			let unit_name = shop.displayedUnit.id;
			if (shop.displayedUnit.bought) {
				// equip/de-equip unit
				if (shop.equippedUnits.indexOf(unit_name) === -1 && shop.equippedUnits.length < 8) {
					shop.equippedUnits.push(unit_name);
				} else {
					let index = shop.equippedUnits.indexOf(unit_name);
					if (index >= 0) {
						shop.equippedUnits.splice(index, 1);
					}
				}
			} else if (shop.funds >= shop.displayedUnit.price) {
				//buy the unit
				shop.funds -= shop.displayedUnit.price;
				shop.displayedUnit.bought = true;
				shop.boughtUnits[unit_name] = shop.availableUnits[unit_name];
				delete shop.availableUnits[unit_name];
			}
		}
	}
}

function mouseScroll(event) {
	let scroll = event.deltaY;
	//blarg
}

function mouseUpCanvas(event) {
	let pos = getMousePos(event);
	if (gameState === "map") {
		let clickedArea = getClickedArea(pos);
		//console.log(clickedArea);
		if (invadableAreas[clickedArea] !== undefined) {
			playerRaces.push(getAreaOwnerId(clickedArea));
			initMatch(clickedArea);
		}
	} else if (gameState === "shop") {
		let clickedSection = getClickedSection(pos);
		if (clickedSection !== undefined) {
			let subscreen = clickedSection[0], new_pos = clickedSection[1];
			handleShopClick(subscreen, new_pos);
		}
	}
	//
	heldButtons = event.buttons;
}

function mouseMoveCanvas(event) {
	heldButtons = event.buttons;
	if (event.target.id === "gameScreen") {
		let pos = getMousePos(event);
		if (gameState === "map") {
			hoveredArea = getClickedArea(pos);
		}
	}
}

function mouseDownCanvas(event) {
	heldButtons = event.buttons;
	if (event.target.id === "gameScreen") {
		let pos = getMousePos(event);
		//maybe save the id of the area that was clicked on
		//mouseDownPos = pos;
	}
}

function contextMenuCanvas(event) {
	//prevent right clicking opening context menu
	//event.preventDefault();
}


function drawCircle(ctx, x, y, radius, color, portion) {
	ctx.strokeStyle = color;
	ctx.beginPath();
	ctx.stroke();
	ctx.beginPath();
	ctx.lineWidth = radius;
	if (portion === undefined) portion = 1;
	ctx.arc(x, y, radius/2, -0.5*Math.PI, Math.PI * (2 * portion - 0.5), false);
	ctx.stroke();
	ctx.lineWidth = 1;
}

function drawLine(ctx, x1, y1, x2, y2, color) {
	ctx.strokeStyle = color;
	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.stroke();
}

function drawRectangleWithText(ctx, x, y, w, h, color_rect, text, color_text, size) {
	drawRectangle(ctx, x, y, w, h, color_rect);
	drawText(ctx, x + w/2, y + h/2, text, color_text, size);
}

function drawRectangle(ctx, x, y, w, h, color, hollow) {
	ctx.fillStyle = color;
	ctx.strokeStyle = color;
	if (hollow) {
		ctx.strokeRect(x,y,w,h);
	} else {
		ctx.fillRect(x,y,w,h);
	}
}

function drawText(ctx, x, y, text, color, size, align) {
	ctx.font = size + "px arial"; 
	ctx.fillStyle = color;
	ctx.textAlign = align || "center";
	ctx.fillText(text, x, y); 
}


function DBP(x1,y1,x2,y2) {
    return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}


drawRectangle(gctx, 0, 0, gameScreen.width, gameScreen.height, "black");
drawText(gctx, gameScreen.width/2, gameScreen.height/2, "Loading...", 50);

</script>
</html>